# HTTP
   HTTP对客户端和服务器端的请求生成报文。
## TCP/IP：四层模型  vs  osi七层模型
### TCP/IP四层
1. 应用层
   向用户提供服务是通信的活动(http/DNS/FTP等)
2. 传输层
   提供处于网络连接中两台电脑间的数据传输(TCP传输控制协议/UDP用户数据协议)
3. 网络层
   用来处理网路上流动的数据包，规定了到达对方计算机的传输路径
4. 链路层 
   用来处理连接网络的硬件部分
   发送端在层与层传输之间，每经过一层就会被打上该层的首部信息，接收端在层与层传输的时候每经过一层就把对应的首部去除。把数据信息包装起来的做法叫封装。
### osi七层模型
1. 应用层
2. 表示层
   数据格式转化、数据加密
3. 会话层
   建立、管理和维护会话
4. 传输层
5. 网络层
6. 数据链路层
   使用链路层地址进行差错检测
7. 物理层
   硬件设备
![]{https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234826351-1957282396.png}
### TCP
   对HTTP的请求报文进行分割成报文段，能够确认数据最终被送到对方。
### IP
   IP是一种协议，IP地址指明了节点被分配到的地址,MAC地址是指网卡所有的固定地址。IP地址可与MAC地址配对，IP地址可更换，MAC地址一般不会更换。
   使用ARP协议(解析地址的协议)进行MAC地址间的通信。
   路由选择：在到达通信目标之前，不确定传输路线，要根据MAC中转站确定下一个中转站直到通信目标。类似快递传输。
## DNS/CDN
   DNS提供域名和IP地址之间的解析服务。
   CDN：一组分布在各个地区的服务器，存储着数据的副本，根据服务器与用户的距离，满足数据的请求。提供快速服务。、
   CDN与前端性能优化：通常被用来存放静态数据（不需要服务器在页面之外额外计算的HTML页面js、css、图片等）。CDN与业务服务器域名不同，而静态资源往往并不需要cookie携带认证信息，这样访问CDN避免了不必要的cookie出现。
   构成：分发服务系统（相应用户需求）；负载均衡系统(对用户的访问进行调度)；运营管理系统（处理业务层面与外界系统的交互）
   核心功能：缓存（把资源copy一份到CDN）与回溯（CDN发现没有资源的时候，向根服务器要资源）
   DNS：实现域名与IP地址相互映射
   DNS（浏览器缓存）：用户输入要访问的域名->浏览器检查缓存中有无域名的对应解析，若没有查找操作系统缓存中，若没有发送给LDNS（本地区域名服务器）->若没有发送给Root Server域名服务器请求解析->Root Server返回给本地区服务器一个主域名服务器地址（.com .cn .org）->LDNS向主域名服务器发送请求->主域名服务器查找并返回对应的name server（用户注册的域名服务器）->name server域名服务器查询存储的域名与ip映射关系表，返回IP地址及TTL值->LDNS缓存这个域名和对应的IP->返回给用户，用户根据TTL值缓存在本地系统
   ![](https://images2015.cnblogs.com/blog/801753/201511/801753-20151102204944102-1846720088.png)
   CDN缓存：同上述过程，在像name server发送的时候，会将域名cname到另一个域名，这个域名指向CDN的负载均衡系统->负载均衡系统会选取最合适的CDN节点ip地址给LDNS->LDNS将获得的ip地址返回给用户->用户像该地址发起请求->如果请求文件不存在，会回到原站获取文件在返回给用户。
   ![](https://img-blog.csdn.net/20180423104123732)
## URI与URL
   URI统一资源标识符：在某个规则下能将这个资源独一无二的标识出来。而URL（统一资源定位符）是它的一个子集，通过定位信息将其标识出来。
## 请求与响应报文
###  请求报文
   ![](https://images0.cnblogs.com/blog2015/471463/201508/121256314895342.png)
### 响应报文
   ![](https://images0.cnblogs.com/blog2015/471463/201508/121327025041622.png)
## HTTP方法
GET(获取资源) POST(传输实体) PUT(传输文件) HEAD(获取报文首部) DELETE(删除文件) OPTIONS(询问支持的方法) TRACE(追踪路径) CONNECTION(要求用隧道协议连接代理：主要使用SSL/TLS协议把通信内容加密后经网络隧道传输)
## 持久连接
   减少了TCP重复建立和连接造成的额外开销，HTTP/1.1中默认持久连接。
## 管线化
   无需等待回应即可发送下一个请求。能够并行发送多个请求。
## cookie
   服务器端发送的响应请求中含有set-cookie，能够通知客户端保存这个cookie，下次请求时带上cookie发送给服务器端，服务器端识别出来后进行响应。
## 分块编码
   将实体主体分为多块进行传输。
## 发送多种数据的多部分对象集合
   采用MIME。
   byteranges：206 包含多个范围使用 
## 状态码
   301：永久重定向 302：暂时重定向  304：未修改
   400：请求报文中存在语法错误 /401 用户认证失败 /403 资源的访问被服务器拒绝 /404 找不到请求的资源
   200 成功处理了请求 /204 服务器返回无内容 /206 指定范围的内容
   100 正在处理 /101 转到另一种协议
   503：服务器暂时无法处理请求
![](https://images2015.cnblogs.com/blog/1030566/201611/1030566-20161113202308702-1568027245.png)
## 单台虚拟机实现多个域名
   允许一台服务器搭建多个web站点，利用了虚拟主机的功能，但是是相同的ip地址。
## 代理 隧道 网关
### 代理：
   中间人，进行转发，附加VIA首部字段标记经过的主机。
   缓存代理：将资源的副本存储在代理服务器上，下次同样的请求时不需要从源服务器获取资源
   透明代理：不对报文进行任何加工。
## 网关
   充当中介，与代理不同，好像它是该服务器的原始服务器，用户可能不知道他与网关通信。能使通信线路上的服务器提供非HTTP协议
## 隧道
   可以提供安全的远距离服务器通讯
## HTTPS
   HTTPS安全通信机制：
   ![](https://upload-images.jianshu.io/upload_images/1064537-cfb9288771054b30.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/713)
   1. 客户端发送报文开始SSL通信，报文中含有客户端支持的SSL版本、加密组建列表。
   2. 服务器端返回报文作为应答，也包含ssl版本及加密组建
   3. 服务器发送CA证书，包含公开密钥证书
   4. 发送报文通知客户端结束SSL协商
   5. SSL第一次握手结束后已经使用公开密钥进行加密，客户端发送包含随机密码串的报文作为回应。（使用发送过来的公开密钥加密过了，并包含了一个随机密码串）
   6. 发送一个报文告诉服务器接下来的通信将采用上面的随机密码串进行加密
   7. 发送结束报文，包含全部报文的校验值
   8. 服务器发送带有随机密码串的报文
   9. 同样发送finished报文
   10. SSL通信完成，进行应用层协议的通讯，发送HTTP请求
   11. 发送HTTP响应
   12. 客户端断开连接

      HTTPS不会一直使用：
   1. 加密消耗更多的cpu，cache
   2. 购买证书也是一笔开销
   3. ssl导致通讯变慢
## 认证
   1. BASIC认证
      发送请求->返回401告知客户端需要认证->用户输入账号密码后发送->认证成功返回200，失败返回401
      认证使用时不够灵活，而且安全等级不够
   2. DIGEST认证
   3. SSL客户端认证
   4. 基于表单认证
## websocket 
   HTTP：
   一条连接上只可以发送一个请求
   请求只能从客户端开始，不可以接受响应以外的指令
   请求/响应未经压缩就发送
   发送冗长的首部
   可选择任意数据压缩格式
   websocket：
   推送功能：服务器可以直接发送数据
   减少通信量：一直保持连接状态
## HTTP攻击
## XSS CSRF SQL注入
### CSRF 攻击
   原理：
   用户访问网站A，A确认身份传给客户端cookie，用户同时访问B网站，B网站直接带上A网站的cookie向A网站发起请求。
   ![](https://raw.githubusercontent.com/huyaocode/webKnowledge/master/img/csrf.png)
   CSRF蠕虫
   用户访问了被攻击页面，同时访问了攻击者页面，攻击者页面使用用户的身份在被攻击的页面发表一些评论或文章，其他的用户查看到该评论时，可能也会被盗用身份发送恶意请求。
   CRSF防御：
    使用验证码，强制用户与应用进行交互
    Referer Check
    HTTP头部有一个字段叫Referer，记录了HTTP请求的来源地址，可以检验请求是否来自合法的源
    添加token验证：后端随机产生一个token，把这个token保存到session中，同时把这个token传给前端；前端页面请求时，把token加到请求数据或头信息中传给后端，后端验证前端传来的token与session中的是否一致，若一致则合法。

### XSS攻击
   攻击者在网站上注入了恶意的客户端代码，通过恶意脚本对客户端代码进行篡改，对用户的浏览器进行控制或者获取用户隐私数据。
   XSS防御：
   将重要的cookie标记为http only，JavaScript的document.write将不会被识别
   表单数据规定值的类型
   对数据进行html实体编码转换
   过滤掉特殊的html标签（如script等）
   过滤js事件的标签
### SQL注入
   把SQL语句插入到web表单提交或输入域名或页面请求的查询字符中，后端直接使用该SQL语句进行查询
   防御:
   永远不要相信用户的输入；永远不要使用动态拼装SQL；不要把机密信息直接存放。
### 强缓存/协商缓存
   浏览器请求资源时，先根据请求头的expires（绝对时间）和cache-control（相对时间）判断是否存在强缓存，如果是，则直接从缓存中读取资源
   如果没有命中强缓存，发送一个请求到服务器，通过last-modified（最后更新的时间，如果之后没有更新，返回304，如果更新过了，返回更新过的资源）和etag（判断内容是否更改）判断是否命中协商缓存，如果命中，将这个请求返回，但不会返回这个资源的数据，数据从缓存中读取。
   如果前面都没有命中，则从服务器直接加载资源
### HTTP2新特性
  二进制分帧层：是HTTP/2.0性能增强的关键，它改变了通信两端交互数据的方式，原先是以文本传输，现在要先对数据进行二进制编码，再把数据分成一个一个的帧，接着把帧送到数据流中，最后对方接受帧并拼接成一条消息，再处理请求
  多路复用：即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个链接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务器端请求里面
  首部压缩：如上文所言。前面提到过的HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小
  服务器推送：HTTP2.0支持服务器主动推送，简单地说就是一次请求返回多个响应，这也是一减少HTTP请求的方法。服务器除了处理最初的请求外，还会额外推送客户端想要的资源，无需客户端发出明确的请求。
